//! Extensible cross-platform GUI application for controlling lab instruments over the network using SCPI commands.
mod devices;
mod networking;
mod messages;
mod styles;
mod screens;

type ScpiCommand = crate::devices::Command;

use iced::{Column, Container, Element, Settings, Sandbox, window, alignment};
use crate::{
    screens::toolbar::ToolBar,
    screens::settings::SettingsScreen,
    screens::command_selection::CommandScreen,
    messages::{Message, ScreenType}};

/// Program entry function
pub fn main() -> iced::Result {
    // TODO: Add ability to read a config from CLI parameter
    MainScreen::run(Settings {
        window: window::Settings {
            size: (700, 400),
            ..Default::default()
        },
        ..Default::default()
    })
}

/// Data and screens held by the application root
#[derive(Default)]
struct MainScreen {
    /// Currently selected [`ScreenType`]
    current_screen: ScreenType,
    /// The [`ToolBar`] displayed at the top row
    toolbar: ToolBar,
    /// The [`SettingsScreen`] where the connection to the device is established
    settings_screen: SettingsScreen,
    /// The [`CommandScreen`] where commands are put together and sent to the device
    command_screen: CommandScreen,
    /// Window title
    title: String,
}


impl Sandbox for MainScreen {
    type Message = Message;

    fn new() -> Self {
        let args: Vec<String> = std::env::args().collect();
        if args.len() < 2 {
            eprintln!("Error: Please specify a config file as the first argument!");
            std::process::exit(-1);
        }

        let config = devices::Configuration::from(&args[1]).unwrap();
        Self {
            command_screen: CommandScreen::from(config),
            settings_screen: SettingsScreen::default(),
            title: String::from("Instrument"),
            ..Default::default()
        }
    }


    fn title(&self) -> String {
        self.title.clone()
    }

    /// Handles all [`Message`]s that are generated by the application
    fn update(&mut self, message: Message) {
        match message {
            Message::ChangeView(v) => { self.current_screen = v }
            Message::Settings(s) => { self.settings_screen.update(s) }
            Message::Command(c) => { self.command_screen.update(c) }
            Message::SendCommand(cmd) => {
                match self.settings_screen.device_connection().send(cmd.as_bytes()) {
                    Ok(n) => {
                        let reply = self.settings_screen.device_connection().receive().unwrap_or("No Reply received!".into());
                        self.command_screen.set_status_text(format!("Reply {} bytes: {}", n, reply));
                    }
                    Err(e) => self.command_screen.set_status_text(format!("Sending command failed! Please check connection.\nError: {}", e))
                }
            }
        }
    }

    /// Show the correct content depending on the application state
    fn view(&mut self) -> Element<Message> {
        Container::new(
            Column::new()
                .padding(8)
                .spacing(8)
                .align_items(alignment::Alignment::Center)
                .push(self.toolbar.view(&self.current_screen))
                .push(match &self.current_screen {
                    ScreenType::Settings => self.settings_screen.view(),
                    ScreenType::Command => self.command_screen.view(),
                })
        )
            .into()
    }

    /// Set the scaling factor, higher number corresponds to "zooming in" on the widgets
    fn scale_factor(&self) -> f64 {
        1.0
    }
}

